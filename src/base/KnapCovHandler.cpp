//
//     MINOTAUR -- It's only 1/2 bull
//
//     (C)opyright 2008 - 2014 The MINOTAUR Team.
//

/**
 * \file KnapCovHandler.h
 * \brief Declare the KnapCovHandler class for handling knapsack cover 
 * constraints. It generates the cuts whenever they are needed. 
 * \author Serdar Yildiz, Argonne National Laboratory
 */

#include <string>
#include <cmath>

#include "KnapCovHandler.h"  
#include "Constraint.h"
#include "Problem.h"
#include "Node.h"
#include "CoverCutGenerator.h"
#include "CutManager.h"
#include "Option.h"

using namespace Minotaur;

typedef std::vector<ConstraintPtr>::const_iterator CCIter;
//const std::string KnapCovHandler::me_ = "KnapCovHandler: ";

// Probably I will disable this function later.
KnapCovHandler::KnapCovHandler()
  : env_(EnvPtr()),
    minlp_(ProblemPtr()),
    stats_(0),
    isFeas_(true),
    solAbsTol_(1e-5)
{
  // This is an abstract class, find a way to make this work such as Logger(log1).
  //logger_ = (LoggerPtr) new Logger();
  intTol_ = env_->getOptions()->findDouble("int_tol")->getValue();
  
}

KnapCovHandler::KnapCovHandler(EnvPtr env, ProblemPtr minlp)
  : env_(env),
    minlp_(minlp),
    stats_(0),
    isFeas_(true),
    solAbsTol_(1e-5)
{
  intTol_ = env_->getOptions()->findDouble("int_tol")->getValue();
  // Initialize logger.
  // Initialize statistics.
  stats_ = new KCStats();
  stats_->knaps = 0;
  stats_->cuts = 0;
  stats_->extended = 0;
  stats_->simple = 0;
  stats_->gns = 0;
  stats_->singlectwo = 0;
  stats_->time  = 0.0;
  stats_->cutdel = 0;
  
}

KnapCovHandler::~KnapCovHandler()
{
  if (stats_) {
    //writeStats(logger_->MsgStream(LogInfo));
    delete stats_;
  }
  //env_.reset();
  //minlp_.reset();
  
}

bool KnapCovHandler::isFeasible(ConstSolutionPtr sol, RelaxationPtr ,
				bool &, double &)
{
  // Get the primal solution.
  const double *x = sol->getPrimal();
  // Evaluation of constraint for a given solution. 
  double activity = 0.0;
  int error = 0;
  
  // Here I assume that the cons_ data element includes the knapsacks cuts
  // that has to be checked for feasibility. Ask Ashu if this is correct or
  // not.!!!

  // Iterators for knapsack constraints.
  CCIter it;
  CCIter begin = cons_.begin();
  CCIter end   = cons_.end();
  // Temporary constraint holder.
  ConstraintPtr cons;
  // Check each knapsack cover constraint if it is violated or not by the solution of
  // relaxation.
  for (it=begin; it!=end; ++it) {
    cons = *it;
    activity = cons->getActivity(x, &error);
    if (activity > cons->getUb() + solAbsTol_ ||
        activity < cons->getLb() - solAbsTol_) {
      isFeas_ = false;
      return false;
    }
  }
  // None of the knapsack cover cuts are violated.
  return true;
}

void KnapCovHandler::separate(ConstSolutionPtr sol, NodePtr,
                              RelaxationPtr rel, CutManager * cmanager,
                              SolutionPoolPtr , bool * ,
                              SeparationStatus * status)
{
  // Check integer feasibility of sol, must add cuts if it is not integral.
  numvars_ = minlp_->getNumVars();
  VariableType type;
  const double * x = sol->getPrimal();
  // Is the relaxation solution is integer feasible.
  bool isintfeas = true;
  // Iterators for variables.
  VariableConstIterator it;
  VariableConstIterator begin = rel->varsBegin();
  VariableConstIterator end   = rel->varsEnd();
  // Temporary variable holder.
  ConstVariablePtr var; 
  // Value of variable.
  double value;

  // Check if integrality is satisfied for each integer variable. 
  for (it=begin; it!=end; ++it) {
    var = *it;
    type = var->getType();
    if (type==Binary || type==Integer) {
      value = x[var->getIndex()];
      if (fabs(value - floor(value + 0.5)) > intTol_) {
        isintfeas = false;
        break;
      }
    }
  }

  if (isintfeas ==  false) {
    // We do another check in CoverCutGneerator for integrality, may be we
    // should eliminate it and use the one above.
    // Generate cover cuts from current relaxation.
    CoverCutGeneratorPtr cover = (CoverCutGeneratorPtr) new CoverCutGenerator(rel,sol, env_);
    // Add cuts to the relaxation by using cut manager.
    CutVector violatedcuts = cover->getViolatedCutList();
    CutIterator itc;
    CutIterator beginc = violatedcuts.begin();
    CutIterator endc   = violatedcuts.end();
    
    // Serdar I am not sure if we should add the constraints generated by
    // addCuts to the constraint vector of knapsack cover handler.
    // Currently CutMan2::addCuts does not add the cuts to the relaxation formulation.
    cmanager->addCuts(beginc, endc);
    
    // Update statistics by using return from cover cut generator.
    ConstCovCutGenStatsPtr covstats = cover->getStats();
    // Later put the code below to updateStats function.
    stats_->knaps += covstats->knaps;
    stats_->cuts += covstats->cuts;
    stats_->extended += covstats->extended;
    stats_->simple += covstats->simple;
    stats_->gns += covstats->gns;
    stats_->singlectwo += covstats->singlectwo;    
  }

  // If any cut is added, the relaxation should be resolved.
  if (stats_->cuts >= 1) {
    *status = SepaResolve;
  }
  
}

// void KnapCovHandler::updateStats(ConstCovCutGenStatsPtr covstats)
// {
  
// }


std::string KnapCovHandler::getName() const 
{
  
  return "KnapCovHandler (Knapsack Cover)";
}

void KnapCovHandler::writeStats(std::ostream &) const
{
}



// Local Variables: 
// mode: c++ 
// eval: (c-set-style "k&r") 
// eval: (c-set-offset 'innamespace 0) 
// eval: (setq c-basic-offset 2) 
// eval: (setq fill-column 78) 
// eval: (auto-fill-mode 1) 
// eval: (setq column-number-mode 1) 
// eval: (setq indent-tabs-mode nil) 
// End:
